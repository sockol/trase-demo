# trase

API demo

## Overview

I made this server using a quickstart-builder-tool: [Autostrada](https://autostrada.dev/).

This is a basic demo, a prod version would have more. Everything is persisted into a local Postgres instance. The api, the DB, and the data is built with docker.

## Quickstart

In the root folder, run this (or get docker if you dont have it)

```
docker compose up
```

This will spin up the api at `localhost:8080`
The db is at:

```
psql postgres://postgres:posgres349@localhost:5432/postgres
```

Or see it here: `https://demo-traseapp-e2ed5fe2afcc.herokuapp.com/`
Same routes as localhost

## API

I tried to go for maximum REST-ness in the api design. All entities have ids, generated by the DB. I went with UUIDs because security - I don't want the public API to be enumerable. Also there are extra routes in the `routes.go` file for documentation and service status.
The naming convention does not sound like good english but this way we group alike things with similar names. Example - if there are 2 api endpoints that deal with users, they both will start with `users` + `ACTION` instead of createUser and getUser.

See the docs for all apis:

```
http://localhost:8080/docs/index.html#
```

## Testing

Most of the logic is in the /handlers module. That is the only part that has unit tests, because time.

```
docker exec -it trase_api /bin/sh -c "go test ./cmd/api/handlers -p 1 -v"
```

## Alternatives Considered and Stuff I Skipped

- No auth, because out of scope.
- Did not add api-level tests, only tx level tests since api handlers have trivial logic and no time.
- Did not optimize endpoints to look at the type of error thrown in the tx functions to determine if we should throw a 404 or 400 and instead check explicitly if the userId exists when creating a post. More readable this way.
- Ids instead of UUIDs. Bad for externally facing apis if we are trying to hide internal info about the entity
- Moving input validation into api middleware. Though on a bigger app this should be a feature.
- Also not handling a bunch of small input validation like checking for empty names, because time.
- Did not use an ORM for simplicity, though we should on prod.
- Also not using any sql gen libraries to convert rows to structs because this is a demo.
- Did not handle proper ctx propagation with timeouts, because time
- Did not split handler files into separate modules, because demo is small. Instead I have a handlers module, that is where most of the logic lives.
- Did not format the api to have this shape because this is a demo:

```
{
    success: bool
    error?: string
    data?: any
}
```
